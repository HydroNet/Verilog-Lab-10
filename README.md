# Verilog-Lab-10
 Introduction
Interrupts are a very important mechanism for large applications to handle multi‐
tasking.  In this lab, SoftWare Interrupt (SWI), Interrupt ReQuest (IRQ), and Fast Interrupt
ReQuests (FIQ) are introduced, and Assembly programs will be written to handle SWI
requests and external interrupts. The objectives include:
 to know how to write SWI, FIQ, and IRQ interrupt service routines
 to learn configuring external interrupt inputs
 to get some familiarity of the Vectored Interrupt Controllers
2 Lab Preparation
Please prepare the lab (e.g., read this section, write the needed subroutines,
assemble them to eliminate any syntax error) before you come to the laboratory. If
possible, you may run your code with RealView Microcontroller Development Kit (RMDK)
simulator.  This will help you to complete the required task on time.  
2.1 GENERAL INTRODUCTION ON INTERRUPTS
During the normal flow of execution in a user program, the Program Counter (PC)
usually increases sequentially through the address space, with occasionally jumping to
here or there due to branch instructions or branch‐and‐link instructions.  
An exception (or interrupt) breaks the normal flow of a user program. Exceptions
could be generated internally or externally to request the processor to handle certain
events or situations. These events include:
 interrupts generated by some peripheral devices
 an attempt to execute an undefined instruction
 a software‐generated interrupt, via the SWI (or SVC) instruction
Table 1. ARM Processor Exceptions
Exception Type Processor Mode Vector Address
Reset Supervisor (SVC) 0x0000 0000
Undefined instructions Undefined (UND) 0x0000 0004
Software Interrupt (SWI) Supervisor 0x0000 0008
Prefetch Abort Abort (ABT) 0x0000 000C
Data Abort Abort 0x0000 0010
Interrupt (IRQ) Interrupt (IRQ) 0x0000 0018
Fast Interrupt (FIQ) Fast Interrupt (FIQ) 0x0000 001C
The ARM processor supports seven types of exceptions, as listed in Table 1. When an
exception occurs, the processor switches to the corresponding processor mode and
California State University, Northridge ECE425L
ECE Department By: Xiaojun Geng
2 
branches to a fixed address that corresponds to that exception. These fixed addresses are
called exception vector addresses which are also specified in Table 1. The 32‐bit
instruction stored in each of these vector addresses is generally a branch instruction to
the corresponding interrupt service routine or interrupt handler. Interrupt handlers are
often written in assembly language to ensure that they execute quickly.
Exceptions may occur asynchronously and unexpectedly; therefore, it is very
important for the processor to save its state before serving the interrupt requests, for
which stacks are used.  
2.2 STACK POINTER INITIALIZATION
Similar to subroutines, stacks are necessary for the interrupt service routines to save
the workspace at the point where the normal flow is diverted. Register r13, also named as
the Stack Pointer (SP), is used to hold the address of the top of the stack in memory.
Before using the stack as storage, the programmer needs to indicate where the stack is by
initializing the SP register with instructions, such as,
LDR    sp, =STACK_TOP
Note that each processor mode has a unique Stack Pointer or register r13. Therefore,
it is necessary to set up the Stack Pointer for every possible processor mode.  One general
approach is to perform all these initializations in the reset handler. More specially, in your
reset handler, you enter each mode with interrupts (I bit and F bit) disabled, and assign
the appropriate value to the stack point. Assume you implement a descending stack, that
is, the newly pushed‐in data is stored in lower address comparing to the previously
pushed‐in data, and the SP decreases as the data is pushed in. With such a stack, an
example is shown below to initialize the SP in Supervisor mode:
Len_SVC_Stack     EQU   0x100 ; # of bytes assigned to the stack in Supervisor mode   
   ⋮
Mode_SVC EQU 0x13 ; Mode bits for Supervisor mode   
   ⋮
SRAM_BASE       EQU    0x40000000 ; Starting address of the SRAM   
I_Bit          EQU   0x80    ; when I bit is set, IRQ is disabled   
F_Bit         EQU   0x40    ; when F bit is set, FIQ is disabled   
Reset_Handler
LDR   r0, =SRAM_BASE+ Len_SVC_Stack  ; Descending stack   
; Enter each mode in turn and set up the stack pointer
MSR       CPSR_c, #Mode_SVC+I_Bit+F_Bit
MOV sp, r0
⋮
The above code is incomplete. You need to finish the code as part of your startup file
in this lab experiment, by assigning initial values to the Stack Pointers for each processor
mode listed in Table 1. As a minimum, your reset handler must assign initial values to the
stack pointers of any execution modes that are used by your application. Note that the
California State University, Northridge ECE425L
ECE Department By: Xiaojun Geng
3 
User mode should be the last one to enter so that the processor will stay in the User
mode after executing the startup code.  
2.3 SOFTWARE INTERRUPT  
SoftWare Interrupt (SWI) is a simple component for microprocessors. It is generated
entirely by software (i.e., user code). For ARM processors, the instructions that initialize
this type of interrupt are SVC (SuperVisor Call) or SWI (early version of SVC). When such
an instruction is executed, the processor switches into Supervisor mode and branch to
the corresponding exception vector address, 0x00000008.  
When the processor executes the SWI or SVC instruction, a series of operations will
be carried out automatically, which include:
(1) copying the address of the next instruction following the SWI instruction into the
LR_svc register;
(2) copying the CPSR into SPSR_svc;
(3) modifies the CPSR mode bits into Supervisor mode;
(4) sets bit 5 (the T bit) of CPSR to zero to enforce ARM state;
(5) sets bit 7 (the I bit) of CPSR to one to disable the normal interrupt requests (IRQs);
(6) loads the address of the exception vector, 0x00000008, to the Program Counter.
Right after the above automatic actions, the software interrupt handler starts to
execute.  It is the responsibility of the interrupt handler to return the control to the calling
program by: (1) copying the return address in the link register LR_svc to PC; and (2)
copying SPSR_svc back to CPSR. These two steps can be performed with a single
instruction:
MOVS pc, lr   ;copy LR to PC and copy SPSR to CPSR
This instruction does the above actions only when the destination register is PC and the
instruction is executed in a privileged mode.  
Question 1: What would happen if “MOV pc, lr” is used instead of “MOVS pc, lr”?  
In the task 1 of this lab experiment, you will use a single SWI call to light up LEDs or
display on the LCD in an interrupt service routine.  
2.4 MULTIPLE SOFTWARE INTERRUPT CALLS  
Software interrupts are very useful. Operating Systems often use multiple SWIs to
provide a large number of services to their clients. However, the ARM processor only
provides one single SWI instruction. This means that the software interrupt handler must
be written in such a way that it can determine which service the caller requires. This is
accomplished by using SWI numbers as part of the instruction code.  
The syntax of the instruction is:
SWI{cond}    #imm ;SWI is replicable by SVC   
where:  
California State University, Northridge ECE425L
ECE Department By: Xiaojun Geng
4 
cond is an optional condition code.
imm is an expression evaluating to an integer (a SWI number) in the range:
 0 to 2ଶସ െ 1 (a 24‐bit value) in an ARM instruction;
 0 െ 255 (an 8‐bit value) in a 16‐bit Thumb instruction.
Remarks:  
(1) SVC was called SWI in earlier versions of the ARM assembly language. SWI instructions
disassemble to SVC, with a comment to say that this was formerly SWI.
(2) The SWI number (imm) is ignored by the processor. In other words, the execution
actions are the same regardless of what SWI number is. However, the number can be
retrieved by the exception handler from the instruction code to determine what service is
being requested. The machine instructions in ARM and Thumb state are presented in
Figure 1.
(a)
(b)
Figure 1. (a) ARM SVC instruction; and (b) Thumb SVC instruction.
(3) Since both ARM and Thumb instruction sets have the SVC instruction, an exception
handler might have to determine whether the processor was in ARM or Thumb state
when the exception occurred. This can be done by examining the SPSR T‐bit.
In the task 2 of this lab experiment, you will use multiple SWI calls to light up LEDs or
display on the LCD in an interrupt service routine.
2.5 EXTERNAL INTERRUPT INPUTS
Seven pins of Port 0 on LPC2148 microcontroller can be configured as external
interrupt inputs. The pin descriptions are included in Table 2.  
Table 2. External Interrupt Pins.
Pin name Pin direction Pin description
EINT0   External Interrupt Input 0 Pins P0.1 and P0.16 can be selected to perform EINT0 function.
EINT1   External Interrupt Input 1 Pins P0.3 and P0.14 can be selected to perform EINT1 function.
EINT2   External Interrupt Input 2 Pins P0.7 and P0.15 can be selected to perform EINT2 function.
EINT3 External Interrupt Input 3 Pins P0.9, P0.20 and P0.30 can be selected for EINT3 function.
California State University, Northridge ECE425L
ECE Department By: Xiaojun Geng
5 
There is a joystick‐switch on the LPC2148 Education Board and its schematic is
illustrated in Figure 2. The switch has five internal push‐down switches, one for each of
the four directions and one for the center. All of the input pins (P0.16 – P0.20) can be
programmed as some type of interrupt inputs. In this lab, we are going to program P0.16
and P0.20 as external interrupt inputs (EINTs) to generate interrupt requests.  
Figure 2. LPC2148 Education Board Schematic: Joystick‐switch.
The details are described below on how to configure the pins P0.16 and P0.20 as
external interrupt (EINT) inputs. First, we modify certain bits of the Pin function select
register 1 (PINSEL1) to select EINT0 and EINT3 function for P0.16 and P0.20, respectively,
according to the bit description given in Table 3. Then, we choose the signal type which
triggers the interrupts. Each EINT pin could be level‐  or edge‐sensitive, selected by
External Interrupt Mode register (EXTMODE ‐ 0xE01F C148), as shown in Table 4.  
Table 3. Partial bits of pin function select register 1 (PINSEL1 ‐ 0xE002 C004)
Bit Pin Value Function
1:0 P0.16 00 GPIO Port 0.16
01 EINT0
10 Match 0.2 (Timer 0)
11 Capture 0.2 (Timer 0)
9:8 P0.20 00 GPIO Port 0.20
01 Match 1.3 (Timer 1)
10 SSEL1 (SSP)
11 EINT3
Next, we select the signal polarity with External Interrupt Polarity register
(EXTPOLAR). In level‐sensitive mode, the bits in this register select whether the
corresponding pin is high‐ or low‐active. In edge‐sensitive mode, they select whether the
pin is rising‐  or falling‐edge sensitive. The bit description of the EXTPOLAR register is
presented in Table 5.  
California State University, Northridge ECE425L
ECE Department By: Xiaojun Geng
6 
Question 2: What signal type will you select for the interrupt inputs connected to the
Joystick‐switch in Figure 2?
Table 4. External Interrupt Mode register (EXTMODE ‐ address 0xE01F C148)  
Bit Bit Symbol Value Description
0 EXTMOD0 0 Level-sensitivity is selected for EINT0.
1 EINT0 is edge sensitive.
1 EXTMOD1 0 Level-sensitivity is selected for EINT1.
1 EINT1 is edge sensitive.
2 EXTMOD2 0 Level-sensitivity is selected for EINT2.
1 EINT2 is edge sensitive.
3 EXTMOD3 0 Level-sensitivity is selected for EINT3.
1 EINT3 is edge sensitive.
7:4   Reserved, user software should not write ones 
to reserved bits.
Table 5. External Interrupt Polarity register (EXTPOLAR ‐ address 0xE01F C14C)
Bit Bit Symbol Value Description
0 EXTPOLAR0 0 EINT0 is low active or falling edge sensitive.
1 EINT0 is high active or rising edge sensitive.
1 EXTPOLAR1 0 EINT1 is low active or falling edge sensitive.
1 EINT1 is high active or rising edge sensitive.
2 EXTPOLAR 2 0 EINT2 is low active or falling edge sensitive.
1 EINT2 is high active or rising edge sensitive.
3 EXTPOLAR 3 0 EINT3 is low active or falling edge sensitive.
1 EINT3 is high active or rising edge sensitive.
7:4   Reserved, user software should not write ones 
to reserved bits.
In the end, there is one more register that needs our attention: External Interrupt
Flag register (EXTINT  ‐  0xE01F C140). When a pin is selected for its external interrupt
function, the selected level or edge on that pin will set its interrupt flag in this register.
This flag bit being “1” asserts the corresponding interrupt request if the interrupt is
enabled and configured. Once the corresponding external interrupt handler starts to
execute, this flag bit in EXTINT must be cleared.  
The bit 0 of the EXTINT register is the flag bit for EINT0 pin, bit 1 is for EINT1 pin, and
so on. The flag bits in EXTINT register can only be cleared by software when the triggering
event is no longer present. Writing a “1” to the bit location of the flag in the register will
clear the flag. For example, the following code clears the EINT2 flag:
MOV   r0, #0x4
LDR    r1, =EXTINT
STR    r0, [r1]
California State University, Northridge ECE425L
ECE Department By: Xiaojun Geng
7 
Question 3: What might happen if the EINT flags were not cleared in the interrupt service
routine?  
In summary, the following steps are necessary to initialize the external interrupt
inputs: (1) configure pin function; (2) select edge/level‐sensitive; (3) choose signal
polarity; and (4) clear EINT flags. After completing the above procedure, we need to
determine the interrupt type generated by EINT inputs: normal interrupt request (IRQ) or
fast interrupt request (FIQ).
2.6 IRQ AND FIQ  
The ARM processor provides two signals that are used by peripherals to request
interrupts: normal interrupt request (IRQ) and fast interrupt request (FIQ). There are two
disable bits in the CPSR register, the I bit and F bit, which are used to enable or disable
the two interrupts respectively. In this lab experiment, you will program both IRQ and FIQ
signals.   
Assume that the bit 7 (I bit)  in CPSR is zero and an IRQ signal has just been asserted,
the ARM processor waits until the current instruction has finished executing, then:
(1) moves the address of the next instruction to be executed, plus 4, into the LR_irq
register;
(2) copies the CPSR into SPSR_irq;
(3) sets the CPSR mode bits to IRQ mode.
(4) clears  bit 5 (the T bit) of CPSR to zero to enforce ARM state;
(5) disables normal interrupts by setting bit 7 (the I bit) of CPSR to one.
(6) Loads the address of the interrupt exception vector, 0x00000018, into the PC.
Right after the above automatic actions, the IRQ interrupt handler starts to execute.  
It is the responsibility of the interrupt handler to return the control to the calling program
by: (1) moving the contents of LR_irq minus 4 into PC; and (2) copying SPSR_svc back to
CPSR. These two steps can be performed with a single instruction:
SUBS  pc, lr, #4    ;copy LR_irq ‐ 4 to PC and copy current SPSR to CPSR  
This instruction does the above actions only when the destination register is PC and the
instruction is executed in a privileged mode.  
Question 4: What will happen to the Link Register if a subroutine call is performed in the
interrupt service routine?  
The ARM processor handles fast interrupt requests in much the same way as normal
interrupts. The differences are that a different set of registers for r8 – r12 are used in FIQ
mode, and both normal and fast interrupts are disabled. Of course, the exception vector
addresses are different too. In this lab, the external interrupt EINT pins connected to the
Joystick‐switch will be programmed to produce IRQ or FIQ signals, which is done through
the Vectored Interrupt Controller.  
California State University, Northridge ECE425L
ECE Department By: Xiaojun Geng
8 
2.7 VECTORED INTERRUPT CONTROLLERS
After completing the above procedure, we need to further program the Vectored
Interrupt Controller (VIC) so that the processor can respond properly to the interrupt
requests. In this lab experiment, we program only the non‐vectored IRQ and FIQ signals.
Many external or internal interrupt signals are connected to the VIC so that they may
generate IRQ or FIQ requests. The Interrupt Select register (VICIntSelect – 0xFFFF F00C)
classifies each of these interrupt sources as contributing to FIQ or IRQ. Each bit in this
register is assigned to one interrupt source. For EINT interrupt inputs, Table 6 shows the
control bit numbers. A “0” in one of these bit locations assigns the corresponding
interrupt signals to the IRQ category, and a “1” to the FIQ category.   
Table 6.  Interrupt Select register (VICIntSelect ‐ address 0xFFFF F00C) partial bit allocation
Bit 17 16 15 14
Symbol EINT3 EINT2 EINT1 EINT0
Access R/W R/W R/W R/W
After choose the proper interrupt category for our interrupt sources, we need to
enable the interrupts by programming Interrupt Enable register (VICIntEnable – 0xFFFF
F010). Similar to VICIntSelect register, this register allocates the same bit locations for
each EINT signal. Writing a “1” in a bit location allows the corresponding interrupt source
to contribute to FIQ or IRQ.  
To disable a certain interrupt source, we need to write a “1” to the bit location (i.e.,
the channel number) assigned to the peripheral in the Interrupt Enable Clear register
(VICIntEnClear – 0xFFFF F014). This register allows software to clear one or more bits in
the VICIntEnable register without first reading it.  
In brief, VICIntSelect register defines the interrupt type (IRQ or FIQ) and
VICIntEnable register puts it into effect. With the above configuration to VIC, the
processor should be able to correspond to the external interrupt inputs as programmed.   
3 Lab Tasks
For the tasks below, complete the following requirements:
 Create ARM assembly program for the first three tasks BEFORE coming to the lab.
 Simulate your code and verify the result with the debugger to make sure that the
program sends the correct data to the control registers and port pins.
 Download the machine code in HEX file to the LPC2148 microcontroller, and verity
the result after execution.
 Demonstrate the results to the lab instructor before you leave the lab.
California State University, Northridge ECE425L
ECE Department By: Xiaojun Geng
9 
Task 1: Modify the startup code you have used in the previous lab experiments so that
the stack initialization is performed in the reset handler for all processor modes that may
be used in this lab experiment. Use this startup code for this and for all the future
experiments.   
Task 2: Write a complete ARM assembly program which calls a single Software Interrupt
to either light up all 8 LEDs connected to P0.15 ‐  P0.8, or display a message on the LCD in
the service routine.  
Task 3: Write a complete ARM assembly program which makes three Software Interrupt
calls to provide different services to each of the three SWI numbers. The services could be
light up different number of LEDs, or display different messages on the LCD.  
Task 4: Write a complete ARM assembly program which configures P0.16 as an external
interrupt input pin to generate an IRQ interrupt signal to the processor. You may either
turn on LEDs or display message on LCDs to be the interrupt service. This task could be
expanded to use both P0.16 and P0.20 to generate interrupts: one IRQ and the other FIQ.  
4 Requirements:
A. This is a two‐week lab experiment. Pre‐lab work will be checked in the beginning
of the lab time. It is very important to complete your pre‐lab which includes
reading through Section 2 of this handout, and write assembly code for first three
tasks.
B. Lab report is DUE one week after the lab time. The report should include your
names, experiment objectives, experiment problems, the print‐out of your work,
explanation and discussion, and conclusion.
C. Demonstrate your results to the instructor before you leave. Failure to do so will
result in zero point for performance
